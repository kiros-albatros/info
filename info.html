<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <ul>
        <li><a href="#1">1. Отличия PHP 7 от PHP 8</a></li>
        <li><a href="#2">2. Интерфейсы, Абстрактный класс, Трейты</a></li>
        <li><a href="#3">3. Принипы ООП</a></li>
        <li><a href="#3.1">3.1. Основные модификаторы</a></li>
        <li><a href="#5">4. SOLID</a></li>
        <li><a href="#6">5. Внедрение зависимостей (Dependency Injection)</a></li>
        <li><a href="#7">6. Паттерны</a></li>
        <li><a href="#8">Laravel</a></li>
        </li>
    </ul>
    <div id="1">1. Отличия PHP 7 от PHP 8 <br>
        PHP 7 был выпущен в декабре 2015 года <br>
        PHP 8 был выпущен в ноябре 2020 <br>
        <ul>
            <li>1) Компиляция JIT (Just-In-Time): PHP 8 представляет JIT, новый механизм компиляции, который значительно
                повышает
                производительность PHP-кода, компилируя его в машинный код во время выполнения.</li>
            <li> 2) Типы объединения: параметр функции или метода может принимать несколько типов значений.
                function foo(int|float $value) {
                // $value может быть либо целым числом, либо числом с плавающей запятой
                }</li>
            <li>
                3) Именованные параметры: передавать аргументы в функцию по имени, а не по положению.
                function sendEmail(string $to, string $subject, string $message, bool $cc = false) {
                // ...
                }
                sendEmail($to: 'info@code-culture.ru', $subject: 'Important message', $message: 'Hello, Alex!');
            </li>
            <li>4) Оператор выбора match, важное отличие switch от match: первый сравнивает нестрого ==, а во втором
                производится
                строгое === сравнение.
                $value = 3;
                $result = match ($value) {
                1 => 'one',
                2 => 'two',
                3 => 'three',
                default => 'other',
                };
                echo $result; // outputs 'three'</li>
            <li>5) Оператор Nullsafe
                $email = $person?->getEmail(); // вернет null если $person is null</li>
            <li>6) Аннотации/Атрибуты (Attributes) как в Symfony (Rust-like синтаксис)
                #[Route('/users/{id}', methods: ['GET'])]
                class UserController {
                #[Route('/')]
                public function index() {
                // ...
                }
                }</li>
            <li> 7) Тип mixed (Mixed Type v2)
                Он эквивалентен типу array|bool|callable|int|float|object|resource|string|null.
                Когда параметр объявлен без типа, то его тип — это mixed.
                Но стоит отметить, что если функция не объявляет возвращаемого значения, то это не mixed, а mixed|void.
                Таким
                образом, если функция гарантированно должна что-то возвращать, но тип результата не известен заранее, то
                стоит
                написать его mixed.</li>
        </ul>
    </div>

    ////////////////////////////////////////////////////////////////////////////////

    <div id="2">
        <ul>
            <li>
                2. Интерфейсы — способ принудительного применения определённых реализаций в классах, которые их
                используют.
                Интерфейсы могут содержать только сигнатуры методов, в них вообще нет никакой функциональности. В
                основном они
                предназначены для обеспечения структуры и служат чертежами для построения классов. Можно использовать
                несколько
                интерфейсов в одном классе. <br>

                interface Bug
                {
                public function legs();
                public function eyes();
                }


                class Spider implements Bug
                {
                public function legs()
                {
                return 8;
                }

                public function eyes()
                {
                return 8;
                }
                }
            </li>
            <li>
                Абстрактный класс используется для определения базового каркаса или проекта дочерних классов. Дочерний
                класс,
                который наследует абстрактный класс, должен реализовывать методы, объявленые абстрактными в родительском
                классе.
                Если неабстрактный класс наследуется от абстрактного класса, то он обязан реализовать все его
                абстрактные
                методы.

                Экземпляры абстрактных классов не могут быть созданы напрямую. <br>

                abstract class car {

                abstract public function modelType();

                public function wheelCount() {
                echo "I have four wheels";
                }
                }
            </li>
            <li>
                Трейты — способ повторного использования кода в нескольких (иногда совершенно несвязанных между собой)
                классах.
                В отличие от абстрактных классов, в одном классе можно использовать несколько трейтов с помощью
                оператора use. <br>

                trait HasFins
                {
                public function swim()
                {
                $laps = 0;
                while (true) {
                $laps++;
                }
                }
                }


                class Duck
                {
                use HasLegs, HasFins;
                }

                $duck = new Duck();
                $duck→swim();
            </li>
        </ul>

    </div>

    ////////////////////////////////////////////////////////////////////////////////

    <div id="3">3. ООП
        <ul>
            <li>Наследование в ООП позволяет создавать новый класс на основе существующего класса, который называется
                родительским классом или суперклассом.</li>
            <li>Инкапсуляция – позволяет скрыть реализацию и детали работы объекта от других частей программы,
                обеспечивая
                доступ только к интерфейсу, который предоставляет объект.</li>
            <li>Полиморфизм – возможность использования одного имени для методов разных классов находящихся в одной
                иерархии
                наследования (т.е. в родственных классах) с целью выполнения схожих действий.</li>
            <li>Абстракция означает выделение главных, наиболее значимых характеристик предмета и
                наоборот — отбрасывание второстепенных, незначительных.</li>
        </ul>

        ////////////////////////////////////////////////////////////////////////////////

        <div>Основные модификаторы
            <ul>
                <li>public — свойство или метод доступны отовсюду. Это значение по умолчанию </li>
                <li>protected — к свойству или методу можно получить доступ внутри класса и классов, производных от
                    этого класса</li>
                <li>private — свойство или метод могут быть доступны ТОЛЬКО внутри класса
        </div>
        </li>
        </ul>
    </div>

    ////////////////////////////////////////////////////////////////////////////////

    <div id="4">4. SOLID
        <ul>
            <li>
                S: Принцип единственной ответственности (Single Responsibility Principle, SRP)
                Важно минимизировать количество случаев, когда вам нужно изменять класс.
            </li>
            <li>O: Принцип открытости/закрытости (Open/Closed Principle, OCP)
                "Программные сущности (классы, модули, функции и т. д.) должны быть открыты для расширения, но закрыты
                для
                модифицирования"</li>
            <li>L: Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
                По этому принципу, подклассы должны быть способны заменять свои родительские классы, от которых они
                наследуются
                без изменения правильности выполнения программы. <br> Ну то есть, что код, который ожидает экземпляр
                базового
                класса,
                должен также корректно работать с экземпляром подкласса без неожиданных побочных эффектов.</li>
            <li>I: Принцип разделения интерфейса (Interface Segregation Principle, ISP)
                Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на
                более
                маленькие и специфические</li>
            <li>D: Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
                классы должны зависеть от абстракций, а не от конкретных деталей. Используется для минимизации
                зацепления в
                компьютерных программах.</li>
        </ul>
    </div>
    ////////////////////////////////////////////////////////////////////////////////

    <div id="5">5. Внедрение зависимостей (или Dependency Injection, сокращенно "DI")
        Зависимость - это объект, который необходим другому объекту, нуждающемуся в зависимости для своей работы.
        Внедрение зависимостей - явная передача зависимости в объект, который в ней нуждается извне, вместо создания
        зависимого объекта в коде нуждающегося. <br>
        Внедрение зависимостей через конструктор считается основным способом использования DI в PHP. <br>

        class UserController <br>
        { <br>
        public function __construct( <br>
        private UserRepository $userRepository <br>
        ) <br>
        {} <br>
        public function handle() <br>
        { <br>
        $user = $this->userRepository->findByEmail('test@test.com'); <br>
        if (empty($user)) { <br>
        throw new \Exception('Пользователь не найден!'); <br>
        } <br>
        return <<<RESPONSE Имя пользователя: $user->name <br>
            RESPONSE;
            }}

            $controller = (new \App\UserController( <br>
            new \App\UserRepository(
            new \App\Db()
            )
            ));
    </div>

    ////////////////////////////////////////////////////////////////////////////////

    <div id="6">6. Паттерны
        <ul>
            <li>Singletone</li>
            <li>Factory (В нём класс просто создаёт объект, который вам необходим),</li>
            <li>Observer</li>
            <li>Фронт-контролер использует единую точку входа для приложения (например, index.php), которая обрабатывает
                все
                запросы.</li>
            <li>Model-View-Controller</li>
        </ul>
    </div>

    ////////////////////////////////////////////////////////////////////////////////

    <div id="7">Laravel <br>

        Фасады предоставляют «статический» интерфейс для классов, доступных в контейнере служб приложения. Laravel из
        коробки включает множество фасадов, обеспечивающих доступ почти ко всему функционалу Laravel. <br>

        мутаторы используются для изменения данных перед их сохранением в базе данных

        Аксессоры и мутаторы (буквально – читатели и преобразователи) позволяют вам форматировать значения атрибутов
        Eloquent при их чтении или записи в экземпляры моделей.
        аксессор в модели
        public function getFirstNameAttribute($value)
        {
        return ucfirst($value);
        }

        мутатор в модели
        public function setFirstNameAttribute($value)
        {
        $this->attributes['first_name'] = strtolower($value);
        }
        <br>

        Чтобы работать с очередями в Laravel, достаточно знать и уметь выполнять несколько команд.
        <ul>
            <li> 1 — Создать обработчик очереди:
                $ php artisan make:job ProcessSendingEmail</li>
            <li>2 — Отправить новое событие в очередь:
                ProcessSendingEmail::dispatch($user);</li>
            <li>3 — И запустить обработчик всех событий:
                $ php artisan queue:work</li>
        </ul>
        События Laravel обеспечивают простую реализацию шаблона Наблюдатель,
    </div>
</body>

</html>